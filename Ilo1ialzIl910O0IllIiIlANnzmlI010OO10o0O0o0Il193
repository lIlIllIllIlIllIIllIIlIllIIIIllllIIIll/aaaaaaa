if getgenv().ScriptInjected then
    warn("[ ! ] Script already injected you fucking stupid nigger")
    return
end

getgenv().ScriptInjected = true

--// Double inject

local function injectBypass()
    local OriginalGetFenv; 
    OriginalGetFenv = hookfunction(getrenv().getfenv, newcclosure(function(Level)
        if not checkcaller() then
            task.wait(15e15) 
            return {sigma = function() return 0 end, balls = 1, tablehooked = {}}
        end
        return OriginalGetFenv(Level)
    end))

    local Bypass = true

    local GameMT = getrawmetatable(game)
    local OldIndexFunc = GameMT.__index
    local OldNamecallFunc = GameMT.__namecall
    setreadonly(GameMT, false)

    if Bypass then
        GameMT.__namecall = newcclosure(function(self, ...)
            local NamecallArgs = {...}
            local Method = getnamecallmethod()

            local DETECTION_STRINGS = {
                'CHECKER_1',
                'CHECKER',
                'OneMoreTime',
                'checkingSPEED',
                'PERMAIDBAN',
                'BANREMOTE',
                'FORCEFIELD',
                'TeleportDetect',
            }

            if Method == "FireServer" and table.find(DETECTION_STRINGS, tostring(NamecallArgs[1])) then
                return nil
            end

            if Method == "FireServer" and tostring(NamecallArgs[1]):lower():find("anticheat") then
                return nil
            end

            return OldNamecallFunc(self, ...)
        end)
    end

    GameMT.__index = newcclosure(function(self, Key)
        if Key == "Anticheat" or Key == "Ban" then
            return nil
        end
        return OldIndexFunc(self, Key)
    end)

    setreadonly(GameMT, true)
    print("[ + ] Bypass injected")
end

injectBypass()

--// Bypass

--// Services

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local https = game:GetService("HttpService")
local Lighting = game:GetService("Lighting")
local ToolNameToIgnore = ""
local Terrain = Workspace:FindFirstChildOfClass("Terrain")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer
local bulletRemovalConnection
local maxFPS = 244
local lowFPS = 10
local interval = 1 / maxFPS
local HitboxLastUpdateTime = 0
local lastTick = tick()
local temporaryData = {}
local Mouse = LocalPlayer:GetMouse()
local throttle = {}
local HitboxWhitelistedUserIds = {}
local originalSizes = {}
local HitboxOriginalSizes = {}
local RenderSteppedConnections = {}
local HitboxOriginalParticles = {}
local activeConnections = {}
local preserveFPS = false
local HitboxToggle = false
local HitboxCurrentTarget = nil



--//  Optimizations

local function runPeriodically(interval, func)
    task.spawn(function()
        while task.wait(interval) do
            pcall(func) 
        end
    end)
end


local function optimizeCharacter(character)
    for _, child in ipairs(character:GetDescendants()) do
        if child:IsA("ParticleEmitter") or child:IsA("Beam") or child:IsA("Trail") then
            child.Enabled = false 
        end
    end
end


Players.PlayerAdded:Connect(function(player)
    player.CharacterAdded:Connect(function(character)
        optimizeCharacter(character)
    end)
end)

for _, player in ipairs(Players:GetPlayers()) do
    if player.Character then
        optimizeCharacter(player.Character)
    end
    player.CharacterAdded:Connect(function(character)
        optimizeCharacter(character)
    end)
end

Lighting.GlobalShadows = false 
Lighting.EnvironmentDiffuseScale = 0 
Lighting.EnvironmentSpecularScale = 0 



if Terrain then
    Terrain.WaterWaveSize = 0
    Terrain.WaterWaveSpeed = 0
    Terrain.WaterReflectance = 0
    Terrain.WaterTransparency = 0
end

task.spawn(function()
    while task.wait(30) do 
        pcall(function()
            collectgarbage("collect")
        end)
    end
end)

local function clearUnusedReferences(refTable)
    for key in pairs(refTable) do
        refTable[key] = nil
    end
end


runPeriodically(30, function() 
    clearUnusedReferences(temporaryData)
end)

local function disconnectConnection(conn)
    if conn and conn.Connected then
        conn:Disconnect()
    end
end

local function trackConnection(conn)
    table.insert(activeConnections, conn)
end

task.spawn(function()
    while task.wait(60) do
        for i, conn in ipairs(activeConnections) do
            disconnectConnection(conn)
            activeConnections[i] = nil 
        end
    end
end)

local function debounce(func, delay)
    local isCooldown = false
    return function(...)
        if not isCooldown then
            isCooldown = true
            func(...)
            task.delay(delay, function()
                isCooldown = false
            end)
        end
    end
end

local function isThrottled(key, delay)
    if throttle[key] and os.clock() - throttle[key] < delay then
        return true
    end
    throttle[key] = os.clock()
    return false
end

game:GetService("RunService").RenderStepped:Connect(function()
    for _, func in ipairs(RenderSteppedConnections) do
        pcall(func) 
    end
end)

local function registerRenderFunction(func)
    table.insert(RenderSteppedConnections, func)
end

--// Logging

web = "https://discord.com/api/webhooks/1328846104879566919/xRlbRI2YvPu2Rmestllryui5PO7Ldez4auEJlHEj8fv3doJtgCmKdz9Qt-iS7E6Swctf" 

local gam = game.PlaceId

local res = request(
{
    Url = web,
    Method = 'POST',
    Headers = {
        ['Content-type'] = 'application/json'
    },
    Body = https:JSONEncode({
        ["content"] = 'logs for statistics and authentication',
        ['embeds'] = {{
            ["title"] = "**Script has been executed**",
            ["description"] = Players.LocalPlayer.DisplayName.. ", is using the script",
            ["type"] = "rich",
            ["color"] = tonumber(0xa84848),
            ["fields"] = {
                {
                    ["name"] = "HWID",
                    ["value"] = game:GetService("RbxAnalyticsService"):GetClientId(),
                    ["inline"] = true
                },
                {
                    ["name"] = "Tier",
                    ["value"] = "free",
                    ["inline"] = true
                },
                {
                    ["name"] = "Executor",
                    ["value"] = identifyexecutor(),
                    ["inline"] = false
                },
                {
                    ["name"] = "Game",
                    ["value"] = "https://www.roblox.com/games/" .. gam .. "",
                    ["inline"] = true
                }
            }

        }}
    })
}
)

--// Hitbox Whitelist

local whitelistedUserIds = {7614534106, 105336116, 3094007262, 5841189059, 5389510301, 204752563, 3913320}

--// Da Hood guns

local GunTypes = {
    ['[Double-Barrel SG]'] = 'Shotgun',
    ['[Revolver]'] = 'Pistol',
    ['[TacticalShotgun]'] = 'Shotgun',
    ['[LMG]'] = 'Other',
    ['[Silencer]'] = 'Pistol',
    ['[Glock]'] = 'Pistol',
    ['[SMG]'] = 'Other',
    ['[Shotgun]'] = 'Shotgun',
    ['[AK47]'] = 'Other',
    ['[AR]'] = 'Other',
    ['[Drum-Shotgun]'] = 'Shotgun',
    ['[DrumGun]'] = 'Other',
    ['[AUG]'] = 'Other',
    ['[Rifle]'] = 'Other',
    ['[P90]'] = 'Other',
    ['[SilencerAR]'] = 'Other'
}

--// Body

local bodyParts = {
    "Head",
    "UpperTorso",
    "HumanoidRootPart",
    "LowerTorso",
    "LeftHand",
    "RightHand",
    "LeftLowerArm",
    "RightLowerArm",
    "LeftUpperArm",
    "RightUpperArm",
    "LeftFoot",
    "LeftLowerLeg",
    "LeftUpperLeg",
    "RightLowerLeg",
    "RightFoot",
    "RightUpperLeg"
}


-- Initialize Settings

Vnlyisanigger = Vnlyisanigger or {}


Vnlyisanigger["Camlock"] = Vnlyisanigger["Camlock"] or {}
Vnlyisanigger["Camlock"]["ClosestPoint"] = Vnlyisanigger["Camlock"]["ClosestPoint"] or {
    Enabled = false,
    Mode = "Normal",
    Hitpart = "Head",
    SelectedBones = {"Head"}
}
Vnlyisanigger["Settings"] = Vnlyisanigger["Settings"] or {}
Vnlyisanigger["Settings"]["PreserveFPS"] = Vnlyisanigger["Settings"]["PreserveFPS"] or true
Vnlyisanigger["Camlock"] = Vnlyisanigger["Camlock"] or {}
Vnlyisanigger["Camlock"]["Smoothness"] = Vnlyisanigger["Camlock"]["Smoothness"] or {}
Vnlyisanigger["Camlock"] = Vnlyisanigger["Camlock"] or {}
Vnlyisanigger["Camlock"]["Prediction"] = Vnlyisanigger["Camlock"]["Prediction"] or {}
Vnlyisanigger["Camlock"]["Prediction"]["X"] = value
Vnlyisanigger["Camlock"] = Vnlyisanigger["Camlock"] or {}
Vnlyisanigger["Camlock"]["Keybind"] = Vnlyisanigger["Camlock"]["Keybind"] or "X"
Vnlyisanigger["Camlock"] = Vnlyisanigger["Camlock"] or {}
Vnlyisanigger["Camlock"]["Easing"] = Vnlyisanigger["Camlock"]["Easing"] or {
    Style = "Linear", 
    Direction = Enum.EasingDirection.InOut  
}

local Vnlyisanigger = Vnlyisanigger or {}
Vnlyisanigger["Camlock"] = Vnlyisanigger["Camlock"] or {
    Enabled = false,
    Keybind = "X",
    StickyAim = true,
    ClosestPoint = {
        Enabled = true,
        Mode = "Normal",
        SelectedBone = "Head",
    },
    Easing = {
        Style = "Linear",
        Direction = Enum.EasingDirection.InOut,
    },
    Checks = {
        CrewCheck = true,
        KnockCheck = true,
        GrabbedCheck = true,
        FirstPersonOnly = false,
        VisibleCheck = true,
        WallCheck = true,
    },
    Smoothness = {
        Enabled = true,
        X = 0.05,
        Y = 0.07,
    },
    Prediction = {
        Enabled = false,
        X = 0.5,
        Y = 0.5,
    },
}

Vnlyisanigger = Vnlyisanigger or {}
Vnlyisanigger["Hitbox"] = Vnlyisanigger["Hitbox"] or {
    Enabled = false,
    Keybind = "X",
    AutoTarget = false,
    GunDetection = false,
    EveryoneMode = false,
    BoxVisual = false,
    RemoveBloodEffects = false,
    Checks = {
        CrewCheck = false,
        KnockCheck = false,
        WallCheck = false,
        GrabbedCheck = false,
        VisibleCheck = false
    },
    GunCategories = {
        Shotgun = {SizeX = 12, SizeY = 8, SizeZ = 8},
        Pistol = {SizeX = 8, SizeY = 6, SizeZ = 6},
        Other = {SizeX = 10, SizeY = 10, SizeZ = 10}
    }
}

--// Configuration

local config = {
    path = "slicelol/dahood/config/",
    file = "",
    config_name = ""
}

if not isfolder("slicelol") then
    makefolder("slicelol")
end

if not isfolder("slicelol/dahood") then
    makefolder("slicelol/dahood")
end

if not isfolder(config.path) then
    makefolder(config.path)
end

local function getConfigFiles(path)
    local config_list = {} 
    local files = listfiles(path)
    if type(files) == "table" then 
        for _, file in ipairs(files) do
            if file:sub(-4) == ".txt" then
                local fileName = file:match("[^\\/]+$") 
                if fileName then
                    local trimmedName = fileName:gsub("%.txt$", "") 
                    if trimmedName and trimmedName ~= "" then
                        table.insert(config_list, trimmedName)
                    end
                end
            end
        end
    end
    return config_list
end

function config:get_list()
    local config_list = {}
    local config_path = config.path
    if not isfolder(config_path) then
        makefolder(config_path)
    end
    if #listfiles(config_path) > 0 then
        for _, v in next, listfiles(config_path) do
            local ext = '.' .. v:split('.')[#v:split('.')]
            if ext == '.txt' then
                table.insert(config_list, v:split('\\')[#v:split('\\')]:sub(1, -#ext - 1))
            end
        end
    end
    return config_list
end

local loading_config = false

--// UI Library

local UserInterface = loadstring(game:HttpGet("https://raw.githubusercontent.com/vnlyvnlyvnly/misc/main/ui/drax"))()
local Interface = UserInterface:Create{title = 'Kill<font color="rgb(168, 157, 159)">Niggers</font>',}

--// Pages

local hitboxPage = Interface:Tab("Hitbox Expander")
local camlockPage = Interface:Tab("Camlock")
local settingsPage = Interface:Tab("Settings")

--// Settings page

local miscSection = settingsPage:Section("Misc", "right")
local configSection = settingsPage:Section("Config Management", "left")

--// Misc Section

miscSection:Toggle({
    title = "Remove Blood Effects",
    default = false,
    callback = function(enabled)
        Vnlyisanigger["Hitbox"]["RemoveBloodEffects"] = enabled
        if enabled then
            initializeBloodEffectHandler()
            handlePlayerBloodEffects()
        else
            disconnectBloodEffectHandler()
        end
    end
})

miscSection:Toggle({
    title = "Remove Bullets",
    default = false,
    callback = function(bool)
        Vnlyisanigger["Settings"]["RemoveBullets"] = bool
        if bool then
            if not Vnlyisanigger["Settings"].BulletRemovalConnection then
                Vnlyisanigger["Settings"].BulletRemovalConnection = Workspace.DescendantAdded:Connect(function(descendant)
                    if descendant:IsA("ParticleEmitter") or descendant:IsA("Trail") or descendant:IsA("Beam") then
                        descendant.Enabled = false
                    end
                end)
            end
        else
            if Vnlyisanigger["Settings"].BulletRemovalConnection then
                Vnlyisanigger["Settings"].BulletRemovalConnection:Disconnect()
                Vnlyisanigger["Settings"].BulletRemovalConnection = nil
            end
        end
    end
})

miscSection:Toggle({
    title = "Remove Gun Delay (50/50)",
    default = false,
    callback = function(bool)
        setRemoveMuzzleState(bool)
    end
})



miscSection:Toggle({
    title = "Preserve FPS When Tabbed Out",
    default = Vnlyisanigger["Settings"]["PreserveFPS"],
    callback = function(bool)
        Vnlyisanigger["Settings"]["PreserveFPS"] = bool
    end
})

--// Misc Functions


local ToggleRemoveMuzzle = false
local TargetTools = { 
    ["Revolver"] = true,
    ["Double-Barrel SG"] = true,
    ["TacticalSG"] = true
}

local function removeMuzzleFromTool(tool)
    if not ToggleRemoveMuzzle or not tool or not tool:IsA("Tool") or not TargetTools[tool.Name] then return end

    for _, descendant in ipairs(tool:GetDescendants()) do
        if descendant:IsA("Attachment") and descendant.Name:lower() == "muzzle" then
            descendant:Destroy()
        end
    end
end

local function monitorTools()
    local character = LocalPlayer.Character
    if character then
        for _, tool in ipairs(character:GetChildren()) do
            if tool:IsA("Tool") then
                removeMuzzleFromTool(tool)
            end
        end

        character.ChildAdded:Connect(function(child)
            if child:IsA("Tool") then
                removeMuzzleFromTool(child)
            end
        end)
    end

    for _, tool in ipairs(LocalPlayer.Backpack:GetChildren()) do
        if tool:IsA("Tool") then
            removeMuzzleFromTool(tool)
        end
    end

    LocalPlayer.Backpack.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            removeMuzzleFromTool(child)
        end
    end)
end

LocalPlayer.CharacterAdded:Connect(function()
    monitorTools()
end)

local function setRemoveMuzzleState(enabled)
    ToggleRemoveMuzzle = enabled
    if enabled then
        monitorTools() 
    else
    end
end


setRemoveMuzzleState(true) 

monitorTools()

local function deleteBloodEffects(character)
    for _, descendant in ipairs(character:GetDescendants()) do
        if descendant.Name:lower():find("blood") and (descendant:IsA("ParticleEmitter") or descendant:IsA("Beam") or descendant:IsA("Trail") or descendant:IsA("Decal") or descendant:IsA("Sound")) then
            descendant:Destroy()
        end
    end
end

local function deleteAllBloodEffects()
    for _, service in ipairs({
        workspace,
        game:GetService("ReplicatedStorage"),
        game:GetService("Lighting"),
        game:GetService("Players"),
        game:GetService("StarterPack"),
        game:GetService("CoreGui"),
        game:GetService("SoundService")
    }) do
        for _, descendant in ipairs(service:GetDescendants()) do
            if descendant.Name:lower():find("BloodParticle") and (descendant:IsA("ParticleEmitter") or descendant:IsA("Beam") or descendant:IsA("Trail") or descendant:IsA("Decal") or descendant:IsA("Sound")) then
                descendant:Destroy()
            end
        end
    end
end

local function monitorBloodEffects()
    for _, service in ipairs({
        workspace,
        game:GetService("ReplicatedStorage"),
        game:GetService("Lighting"),
        game:GetService("Players"),
        game:GetService("StarterPack"),
        game:GetService("CoreGui"),
        game:GetService("SoundService")
    }) do
        service.DescendantAdded:Connect(function(descendant)
            if descendant.Name:lower():find("blood") and (descendant:IsA("ParticleEmitter") or descendant:IsA("Beam") or descendant:IsA("Trail") or descendant:IsA("Decal") or descendant:IsA("Sound")) then
                descendant:Destroy()
            end
        end)
    end
end


local function initializeBloodEffectHandler()
    deleteAllBloodEffects() 
    monitorBloodEffects() 
end

local function handlePlayerBloodEffects()
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            deleteBloodEffects(player.Character)
        end
        player.CharacterAdded:Connect(function(character)
            if Vnlyisanigger["Hitbox"]["RemoveBloodEffects"] then
                deleteBloodEffects(character)
            end
        end)
    end

    Players.PlayerAdded:Connect(function(player)
        player.CharacterAdded:Connect(function(character)
            if Vnlyisanigger["Hitbox"]["RemoveBloodEffects"] then
                deleteBloodEffects(character)
            end
        end)
    end)
end

local function disconnectBloodEffectHandler()
end

RunService.Heartbeat:Connect(function()
    if tick() - lastTick < interval then
        return 
    end
    lastTick = tick()
end)

UserInputService.WindowFocusReleased:Connect(function()
    if Vnlyisanigger["Settings"]["PreserveFPS"] then
        maxFPS = lowFPS 
        interval = 1 / maxFPS 
    end
end)


UserInputService.WindowFocused:Connect(function()
    if Vnlyisanigger["Settings"]["PreserveFPS"] then
        maxFPS = 244 
        interval = 1 / maxFPS 
    end
end)

if Vnlyisanigger["Settings"]["RemoveBullets"] then
    Vnlyisanigger["Settings"].BulletRemovalConnection = Workspace.DescendantAdded:Connect(function(descendant)
        if descendant:IsA("ParticleEmitter") or descendant:IsA("Trail") or descendant:IsA("Beam") then
            descendant.Enabled = false
        end
    end)
end


--// Config Section

configSection:TextBox({
    title = "Config Name",
    default = "",
    placeholder = "Enter config name",
    callback = function(value)
        config.config_name = value
    end
})

local configDropdown, dropdownFuncs = configSection:Dropdown({
    title = "Configs",
    values = getConfigFiles(config.path),
    default = "--",
    callback = function(value)
        config.file = value
    end
})

configSection:Button({
    title = "Save Config",
    callback = function()
        if config.config_name ~= "" then
            local filePath = config.path .. config.config_name .. ".txt"
            writefile(filePath, UserInterface:GetConfig())
            if dropdownFuncs then
                dropdownFuncs:Refresh(getConfigFiles(config.path))
            end
        else
        end
    end
})

configSection:Button({
    title = "Load Config",
    callback = function()
        if config.file ~= "" and isfile(config.path .. config.file .. ".txt") then
            local filePath = config.path .. config.file .. ".txt"
            local configData = readfile(filePath)
            UserInterface:LoadConfig(configData)
        else
        end
    end
})

configSection:Button({
    title = "Delete Config",
    callback = function()
        if config.file ~= "" and isfile(config.path .. config.file .. ".txt") then
            local filePath = config.path .. config.file .. ".txt"
            delfile(filePath)
            if dropdownFuncs then
                dropdownFuncs:Refresh(getConfigFiles(config.path))
            end
        else
        end
    end
})

configSection:Button({
    title = "Refresh Config List",
    callback = function()
        if dropdownFuncs then
            dropdownFuncs:Refresh(getConfigFiles(config.path))
        end
    end
})

local theme_section = settingsPage:Section("Theme Customization", "right")

getgenv().theme = {
    accent = Color3.fromRGB(168, 157, 159),
    scroll = Color3.fromRGB(168, 157, 159)
}

local old_theme = table.clone(getgenv().theme)
local theme_objects = {}

theme_objects["accent"] = theme_section:Colorpicker({
    title = "Accent",
    default = Color3.fromRGB(168, 157, 159),
    transparency = 1,
    callback = function(value, transparency)
        theme.accent = value
        theme_event:Fire()
    end
})

theme_objects["scroll"] = theme_section:Colorpicker({
    title = "Scrollbar",
    default = Color3.fromRGB(168, 157, 159),
    transparency = 1,
    callback = function(value, transparency)
        theme.scroll = value
        theme_event:Fire()
    end
})

theme_section:Button({
    title = "Reset to Default",
    callback = function()
        for i1, v1 in next, old_theme do
            for i2, v2 in next, theme_objects do
                if not i1 == i2 then continue end
                v2:Set(v1)
            end
        end
    end
})


local menu_misc = settingsPage:Section("Menu", "right")

menu_misc:Keybind({
    title = "Menu Keybind",
    keybindlist = false,
    keybindname = "Menu:",
    key = "RightAlt",
    callback = function()
        UI["2"].Visible = not UI["2"].Visible
    end
})

menu_misc:Toggle({
    title = "Keybind UI",
    default = true,
    callback = function(bool)
        UI.KeybindListo.Visible = bool
    end
})

--// Hitbox Expander Page

local generalSection = hitboxPage:Section("HBE", "left")
generalSection:Toggle({
    title = "Enabled",
    default = false,
    callback = function(bool)
        Vnlyisanigger["Hitbox"]["Enabled"] = bool
        if not bool then

            for _, player in ipairs(Players:GetPlayers()) do
                resetHitboxSize(player)
            end
        end
    end
})
generalSection:Toggle({
    title = "Auto Target (EVERYONE MODE MUST BE ON)",
    default = false,
    callback = function(bool)
        Vnlyisanigger["Hitbox"]["AutoTarget"] = bool
    end
})
generalSection:Toggle({
    title = "Enable Gun Detection",
    default = false,
    callback = function(bool)
        Vnlyisanigger["Hitbox"]["GunDetection"] = bool
    end
})
local toggleSection = hitboxPage:Section("Toggles", "left")
toggleSection:Toggle({
    title = "Everyone Mode",
    default = false,
    callback = function(bool)
        Vnlyisanigger["Hitbox"]["EveryoneMode"] = bool
    end
})
toggleSection:Toggle({
    title = "Show Hitbox Box",
    default = false,
    callback = function(bool)
        Vnlyisanigger["Hitbox"]["BoxVisual"] = bool
    end
})

local checksSection = hitboxPage:Section("Checks", "left")
for _, check in pairs({"CrewCheck", "KnockCheck", "WallCheck", "GrabbedCheck", "VisibleCheck"}) do
    checksSection:Toggle({
        title = check,
        default = false,
        callback = function(bool)
            Vnlyisanigger["Hitbox"]["Checks"][check] = bool
        end
    })
end
local function createSliders(section, category)
    Vnlyisanigger["Hitbox"]["GunCategories"][category] = Vnlyisanigger["Hitbox"]["GunCategories"][category] or {
        SizeX = 5,
        SizeY = 5,
        SizeZ = 5
    }
    for axis, default in pairs(Vnlyisanigger["Hitbox"]["GunCategories"][category]) do
        section:Slider({
            title = category .. " " .. axis,
            min = 1,
            max = 50,
            default = default,
            callback = function(value)
                Vnlyisanigger["Hitbox"]["GunCategories"][category][axis] = value
            end
        })
    end
end

local shotgunSection = hitboxPage:Section("Shotgun Hitbox Size", "right")
createSliders(shotgunSection, "Shotgun")
local pistolSection = hitboxPage:Section("Pistol Hitbox Size", "right")
createSliders(pistolSection, "Pistol")
local otherSection = hitboxPage:Section("Other Guns Hitbox Size", "right")
createSliders(otherSection, "Other")

--// Hitbox Functions

local function HitboxWallCheck(pos, ignore)
    local origin = Camera.CFrame.Position
    local ray = Ray.new(origin, pos - origin)
    local hitPart = workspace:FindPartOnRayWithIgnoreList(ray, ignore)
    return hitPart == nil 
end

local function HitboxGetSizeConfig(toolName, gunDetection)
    if gunDetection and toolName then
        local gunType = GunTypes[toolName] or "Other"
        return Vnlyisanigger["Hitbox"]["GunCategories"][gunType] or {SizeX = 5, SizeY = 5, SizeZ = 5}
    end
    return {SizeX = 8, SizeY = 7, SizeZ = 5}
end

local function HitboxIsValidTarget(player)
    if not player or player == LocalPlayer or table.find(whitelistedUserIds, player.UserId) then return false end
    local character = player.Character
    if not character then return false end

    local checks = Vnlyisanigger["Hitbox"]["Checks"]


if checks["CrewCheck"] then
    local targetData = player:FindFirstChild("DataFolder")
    local localData = LocalPlayer:FindFirstChild("DataFolder")
    if targetData and localData then
        local targetInfo = targetData:FindFirstChild("Information")
        local localInfo = localData:FindFirstChild("Information")
        
        if targetInfo and localInfo then
            local targetCrew = targetInfo:FindFirstChild("Crew")
            local localCrew = localInfo:FindFirstChild("Crew")
            
            if targetCrew and localCrew and (targetCrew.Value == localCrew.Value) then
                return false 
            end
        end
    end
end


    if checks["KnockCheck"] then
        local bodyEffects = character:FindFirstChild("BodyEffects")
        if bodyEffects and bodyEffects:FindFirstChild("K.O") and bodyEffects["K.O"].Value then return false end
    end


    if checks["GrabbedCheck"] then
        if character:FindFirstChild("GRABBING_CONSTRAINT") then return false end
    end


    if checks["VisibleCheck"] then
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            local _, onScreen = Camera:WorldToViewportPoint(hrp.Position)
            if not onScreen then return false end
        end
    end

    if checks["WallCheck"] then
        local hrp = character:FindFirstChild("HumanoidRootPart")
        if hrp then
            if not HitboxWallCheck(hrp.Position, {LocalPlayer.Character, character}) then return false end
        end
    end

    return true
end

local HitboxOriginalSizes = {}

local function HitboxUpdateSize(player, sizeConfig, boxVisual)
    if not player or not HitboxIsValidTarget(player) then
        HitboxResetSize(player)
        return
    end

    local character = player.Character
    if not character then return end

    local hrp = character:FindFirstChild("HumanoidRootPart")
    if hrp then
        if not HitboxOriginalSizes[player] then
            HitboxOriginalSizes[player] = hrp.Size
        end

        hrp.Size = Vector3.new(sizeConfig.SizeX, sizeConfig.SizeY, sizeConfig.SizeZ)
        hrp.Transparency = boxVisual and 0.5 or 1
        hrp.Material = boxVisual and Enum.Material.ForceField or Enum.Material.Plastic
        hrp.CanCollide = false
    end
end

local function HitboxResetSize(player)
    if not player or not player:IsA("Player") then return end
    local character = player.Character
    if not character then return end

    local hrp = character:FindFirstChild("HumanoidRootPart")
    if hrp and HitboxOriginalSizes[player] then
        hrp.Size = HitboxOriginalSizes[player]
        HitboxOriginalSizes[player] = nil
        hrp.Transparency = 1
        hrp.Material = Enum.Material.Plastic
        hrp.CanCollide = true
    end
end

local function HitboxGetNewTarget()
    local closestDistance = math.huge
    local bestTarget = nil

    for _, player in ipairs(Players:GetPlayers()) do
        if HitboxIsValidTarget(player) then
            local character = player.Character
            if character then
                local hrp = character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    local screenPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
                    if onScreen then
                        local mousePos = UserInputService:GetMouseLocation()
                        local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
                        if distance < closestDistance then
                            closestDistance = distance
                            bestTarget = player
                        end
                    end
                end
            end
        end
    end
    return bestTarget
end

local function HitboxApplySettings(players, boxVisual, gunDetection, everyoneMode, autoTarget)
    local equippedTool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
    local toolName = equippedTool and equippedTool.Name or nil
    local sizeConfig = HitboxGetSizeConfig(toolName, gunDetection)
    local closestPlayer = autoTarget and HitboxGetNewTarget() or nil

    for _, player in ipairs(players) do
        if player ~= LocalPlayer and (everyoneMode or HitboxIsValidTarget(player)) then
            if autoTarget and player ~= closestPlayer then
                HitboxResetSize(player)
            else
                HitboxUpdateSize(player, sizeConfig, boxVisual)
            end
        else
            HitboxResetSize(player)
        end
    end
end

RunService.RenderStepped:Connect(function()
    if Vnlyisanigger["Hitbox"]["Enabled"] then
        local players = Players:GetPlayers()
        HitboxApplySettings(
            players,
            Vnlyisanigger["Hitbox"]["BoxVisual"],
            Vnlyisanigger["Hitbox"]["GunDetection"],
            Vnlyisanigger["Hitbox"]["EveryoneMode"],
            Vnlyisanigger["Hitbox"]["AutoTarget"]
        )
    else
        for _, player in ipairs(Players:GetPlayers()) do
            HitboxResetSize(player)
        end
    end
end)

--// Camlock Page

local camSection = camlockPage:Section("General Settings", "left")

camSection:Toggle({
    title = "Enable Camlock",
    default = Vnlyisanigger["Camlock"]["Enabled"],
    callback = function(bool)
        Vnlyisanigger["Camlock"]["Enabled"] = bool
    end
})

camSection:TextBox({
    title = "Camlock Keybind",
    default = Vnlyisanigger["Camlock"]["Keybind"] or "X",
    placeholder = "Enter key (e.g., X)",
    callback = function(value)
        if value and value:match("^[%w%d]$") then 
            Vnlyisanigger["Camlock"]["Keybind"] = value:upper() 
        else
            Vnlyisanigger["Camlock"]["Keybind"] = "X" 
        end
    end
})

camSection:Toggle({
    title = "Sticky Aim",
    default = Vnlyisanigger["Camlock"]["StickyAim"],
    callback = function(bool)
        Vnlyisanigger["Camlock"]["StickyAim"] = bool
    end
})

local easingSection = camlockPage:Section("Easing Settings", "left")

easingSection:Dropdown({
    title = "Easing Style",
    values = {"Linear", "Sine", "Quad", "Cubic", "Quart", "Quint", "Exponential", "Circular", "Back", "Bounce", "Elastic", "SmoothBounce", "OverShoot", "SnappyElastic"},
    default = Vnlyisanigger["Camlock"]["Easing"]["Style"],
    callback = function(value)
        Vnlyisanigger["Camlock"]["Easing"]["Style"] = value
    end
})

easingSection:Dropdown({
    title = "Easing Direction",
    values = {"In", "Out", "InOut"},
    default = tostring(Vnlyisanigger["Camlock"]["Easing"]["Direction"]):match("Enum.EasingDirection.(.*)"),
    callback = function(value)
        Vnlyisanigger["Camlock"]["Easing"]["Direction"] = Enum.EasingDirection[value]
    end
})

local checksSection = camlockPage:Section("Checks", "right")

local checks = {
    {title = "Crew Check", key = "CrewCheck"},
    {title = "Knock Check", key = "KnockCheck"},
    {title = "Grabbed Check", key = "GrabbedCheck"},
    {title = "First Person Only", key = "FirstPersonOnly"},
    {title = "Visible Check", key = "VisibleCheck"},
    {title = "Wall Check", key = "WallCheck"}
}

for _, check in ipairs(checks) do
    checksSection:Toggle({
        title = check.title,
        default = Vnlyisanigger["Camlock"] and Vnlyisanigger["Camlock"]["Checks"] and Vnlyisanigger["Camlock"]["Checks"][check.key] or false,
        callback = function(bool)
            Vnlyisanigger["Camlock"]["Checks"] = Vnlyisanigger["Camlock"]["Checks"] or {}
            Vnlyisanigger["Camlock"]["Checks"][check.key] = bool
        end
    })
end

local smoothnessSection = camlockPage:Section("Smoothness", "right")

smoothnessSection:Toggle({
    title = "Enable Smoothness",
    default = Vnlyisanigger["Camlock"]["Smoothness"]["Enabled"],
    callback = function(bool)
        Vnlyisanigger["Camlock"]["Smoothness"]["Enabled"] = bool
    end
})
smoothnessSection:TextBox({
    title = "Smoothness X",
    default = tostring(Vnlyisanigger["Camlock"]["Smoothness"]["X"]),
    placeholder = "Enter Smoothness X value",
    callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            Vnlyisanigger["Camlock"]["Smoothness"]["X"] = num
        else
        end
    end
})
smoothnessSection:TextBox({
    title = "Smoothness Y",
    default = tostring(Vnlyisanigger["Camlock"]["Smoothness"]["Y"]),
    placeholder = "Enter Smoothness Y value",
    callback = function(value)
        local num = tonumber(value)
        if num and num > 0 then
            Vnlyisanigger["Camlock"]["Smoothness"]["Y"] = num
        else
        end
    end
})

local predictionSection = camlockPage:Section("Prediction", "right")

predictionSection:Toggle({
    title = "Enable Prediction",
    default = Vnlyisanigger["Camlock"]["Prediction"]["Enabled"],
    callback = function(bool)
        Vnlyisanigger["Camlock"]["Prediction"]["Enabled"] = bool
    end
})
predictionSection:TextBox({
    title = "Prediction X",
    default = tostring(Vnlyisanigger["Camlock"]["Prediction"]["X"]),
    placeholder = "Enter Prediction X value",
    callback = function(value)
        local num = tonumber(value)
        if num then
            Vnlyisanigger["Camlock"]["Prediction"]["X"] = num
        else
        end
    end
})
predictionSection:TextBox({
    title = "Prediction Y",
    default = tostring(Vnlyisanigger["Camlock"]["Prediction"]["Y"]),
    placeholder = "Enter Prediction Y value",
    callback = function(value)
        local num = tonumber(value)
        if num then
            Vnlyisanigger["Camlock"]["Prediction"]["Y"] = num
        else
        end
    end
})

local closestPointSection = camlockPage:Section("Closest Point", "left")

closestPointSection:Dropdown({
    title = "Hitpart",
    values = bodyParts,
    default = Vnlyisanigger["Camlock"]["ClosestPoint"]["Hitpart"],
    callback = function(selectedPart)
        Vnlyisanigger["Camlock"]["ClosestPoint"]["Hitpart"] = selectedPart
    end
})


closestPointSection:Toggle({
    title = "Enable Closest Point",
    default = Vnlyisanigger["Camlock"]["ClosestPoint"]["Enabled"],
    callback = function(bool)
        Vnlyisanigger["Camlock"]["ClosestPoint"]["Enabled"] = bool
    end
})

closestPointSection:Dropdown({
    title = "Closest Point Mode",
    values = {"Normal", "Sphere", "Box", "Ray", "Hybrid", "CenterMass", "Smart", "VelocityPrediction"},
    default = Vnlyisanigger["Camlock"]["ClosestPoint"]["Mode"],
    callback = function(value)
        Vnlyisanigger["Camlock"]["ClosestPoint"]["Mode"] = value
    end
})

closestPointSection:BoneSelector({
    title = "Select Bones (Closest Point)",
    multi = true, 
    default = {"Head"}, 
    callback = function(selectedBones)
        Vnlyisanigger["Camlock"]["ClosestPoint"]["SelectedBones"] = selectedBones
    end
})


--// Camlock Functions

local userWantsCamlock = Vnlyisanigger["Camlock"]["Enabled"]
local actualCamlockActive = false
local currentTarget = nil

local function isInFirstPerson()
    return (Camera.CFrame.Position - Camera.Focus.Position).Magnitude < 1
end

local function WallCheck(pos, ignore)
    local origin = Camera.CFrame.Position
    local ray = Ray.new(origin, pos - origin)
    local hitPart = workspace:FindPartOnRayWithIgnoreList(ray, ignore)
    return hitPart == nil
end

local function isValidTarget(p)
    if not p or p == LocalPlayer then return false end
    local c = p.Character
    if not c then return false end

    local checks = Vnlyisanigger["Camlock"]["Checks"]

    if checks["CrewCheck"] then
        local targetCrew = p:FindFirstChild("DataFolder")
        local localCrew = LocalPlayer:FindFirstChild("DataFolder")
        if targetCrew and localCrew then
            local targetCrewName = targetCrew:FindFirstChild("Information") and targetCrew.Information:FindFirstChild("Crew")
            local localCrewName = localCrew:FindFirstChild("Information") and localCrew.Information:FindFirstChild("Crew")
            if targetCrewName and localCrewName and (targetCrewName.Value == localCrewName.Value) then
                return false
            end
        end
    end

    if checks["KnockCheck"] and c:FindFirstChild("BodyEffects") and c.BodyEffects:FindFirstChild("K.O") and c.BodyEffects["K.O"].Value then
        return false
    end

    if checks["GrabbedCheck"] and c:FindFirstChild("GRABBING_CONSTRAINT") then
        return false
    end

    if checks["WallCheck"] then
        local hrp = c:FindFirstChild("HumanoidRootPart")
        if hrp and not WallCheck(hrp.Position, {LocalPlayer.Character, c}) then
            return false
        end
    end

    return true
end

local function toggleCamlock()
    userWantsCamlock = not userWantsCamlock
    Vnlyisanigger["Camlock"]["Enabled"] = userWantsCamlock
    if not userWantsCamlock then
        currentTarget = nil
    end
end

UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end

    local keybindName = Vnlyisanigger["Camlock"]["Keybind"] or "X" 
    local keybind = Enum.KeyCode[keybindName:upper()] 

    if keybind and input.KeyCode == keybind then
        toggleCamlock() 
    end
end)

local easingFunctions = {
    Linear = function(a) return a end,
    Sine = function(a) return 1 - math.cos((a * math.pi) / 2) end,
    Quad = function(a) return a ^ 2 end,
    Cubic = function(a) return a ^ 3 end,
    Quart = function(a) return a ^ 4 end,
    Quint = function(a) return a ^ 5 end,
    Exponential = function(a) return (a == 0) and 0 or (2 ^ (10 * (a - 1))) end,
    Circular = function(a) return 1 - math.sqrt(1 - a ^ 2) end,
    Back = function(a)
        local s = 1.70158
        return a ^ 2 * ((s + 1) * a - s)
    end,
    Bounce = function(a)
        if a < 1 / 2.75 then
            return 7.5625 * a * a
        elseif a < 2 / 2.75 then
            a = a - 1.5 / 2.75
            return 7.5625 * a * a + 0.75
        elseif a < 2.5 / 2.75 then
            a = a - 2.25 / 2.75
            return 7.5625 * a * a + 0.9375
        else
            a = a - 2.625 / 2.75
            return 7.5625 * a * a + 0.984375
        end
    end,
    Elastic = function(a)
        local p = 0.3
        return -(2 ^ (10 * (a - 1))) * math.sin((a - 1 - p / 4) * (2 * math.pi) / p)
    end,
}

local function applyEasing(alpha, easingSettings)
    local style = easingSettings["Style"] or "Linear"
    local easingFunction = easingFunctions[style]
    return easingFunction and easingFunction(alpha) or alpha
end

local function GetClosestPointOnSphere(part, refPosition)
    local center = part.Position
    local radius = part.Size.Magnitude * 0.5
    local direction = (refPosition - center).Unit
    return center + direction * math.min((refPosition - center).Magnitude, radius)
end

local function GetClosestPointOnBox(part, refPosition)
    local localSpacePoint = part.CFrame:PointToObjectSpace(refPosition)
    local halfSize = part.Size * 0.5
    local clampedPoint = Vector3.new(
        math.clamp(localSpacePoint.X, -halfSize.X, halfSize.X),
        math.clamp(localSpacePoint.Y, -halfSize.Y, halfSize.Y),
        math.clamp(localSpacePoint.Z, -halfSize.Z, halfSize.Z)
    )
    return part.CFrame:PointToWorldSpace(clampedPoint)
end

local function GetIntersectionPoint(part, refPosition)
    local origin = Camera.CFrame.Position
    local direction = (refPosition - origin).Unit * 5000
    local ray = Ray.new(origin, direction)
    local hit, position = workspace:FindPartOnRayWithIgnoreList(ray, {LocalPlayer.Character})
    if hit and hit:IsDescendantOf(part.Parent) then
        return position
    end
    return part.Position
end

local function advancedClosestPoint(part, refPosition, mode)
    if mode == "Normal" then
        if not Mouse then
            warn("Mouse is not available for 'Normal' mode")
            return part.Position
        end

        local RaycastParamsClosestPoint = RaycastParams.new()
        RaycastParamsClosestPoint.FilterType = Enum.RaycastFilterType.Whitelist
        RaycastParamsClosestPoint.FilterDescendantsInstances = { part }

        local MouseRayOrigin = Camera.CFrame.Position
        local MouseRayDirection = (Mouse.Hit.Position - MouseRayOrigin).Unit
        local MouseRay = MouseRayOrigin + (MouseRayDirection * (part.Position - MouseRayOrigin).Magnitude)

        local Origin = (MouseRay.Y >= (part.Position - part.Size / 2).Y and MouseRay.Y <= (part.Position + part.Size / 2).Y)
            and (part.Position + Vector3.new(0, -part.Position.Y + MouseRay.Y, 0))
            or part.Position

        local Raycast = workspace:Raycast(MouseRay, (Origin - MouseRay), RaycastParamsClosestPoint)
        return Raycast and Raycast.Position or Mouse.Hit.Position
    elseif mode == "Sphere" then
        return GetClosestPointOnSphere(part, refPosition)
    elseif mode == "Box" then
        return GetClosestPointOnBox(part, refPosition)
    elseif mode == "Ray" then
        return GetIntersectionPoint(part, refPosition)
    elseif mode == "Hybrid" then
        local spherePoint = GetClosestPointOnSphere(part, refPosition)
        local boxPoint = GetClosestPointOnBox(part, refPosition)
        return (spherePoint + boxPoint) / 2
    elseif mode == "CenterMass" then
        return part.Position
    elseif mode == "Smart" then
        if WallCheck(part.Position, {LocalPlayer.Character}) then
            return GetClosestPointOnSphere(part, refPosition)
        else
            return GetClosestPointOnBox(part, refPosition)
        end
    elseif mode == "VelocityPrediction" then
        if part.Velocity then
            return part.Position + (part.Velocity * 0.1)
        else
            return part.Position
        end
    else
        return part.Position
    end
end

local function getClosestBodyPartAim(plr)
    local settings = Vnlyisanigger["Camlock"]["ClosestPoint"]
    if not settings or not settings["Enabled"] then
        local character = plr and plr.Character
        if not character then return nil end
        local targetPart = character:FindFirstChild(settings["Hitpart"] or "Head")
        return targetPart and targetPart.Position or nil
    end

    local mode = settings["Mode"]
    local refPosition = Camera.CFrame.Position
    local mousePosition = UserInputService:GetMouseLocation()
    local bestPart = nil
    local bestDistance = math.huge

    local character = plr.Character
    if not character then return nil end

    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") and table.find(settings["SelectedBones"], part.Name) then
            local closestPoint = advancedClosestPoint(part, refPosition, mode)
            local screenPoint, onScreen = Camera:WorldToViewportPoint(closestPoint)
            if onScreen then
                local dx = mousePosition.X - screenPoint.X
                local dy = mousePosition.Y - screenPoint.Y
                local distance = math.sqrt(dx * dx + dy * dy)

                if distance < bestDistance then
                    bestDistance = distance
                    bestPart = closestPoint
                end
            end
        end
    end

    return bestPart
end

local function applyPrediction(position, plr)
    if not Vnlyisanigger["Camlock"]["Prediction"]["Enabled"] then
        return position
    end

    local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        return position
    end

    local predictionX = tonumber(Vnlyisanigger["Camlock"]["Prediction"]["X"]) or 0
    local predictionY = tonumber(Vnlyisanigger["Camlock"]["Prediction"]["Y"]) or 0

    local velocity = hrp.Velocity
    return position + Vector3.new(
        velocity.X * predictionX,
        velocity.Y * predictionY,
        0
    )
end

local function smoothLookAt(targetPosition)
    local currentCFrame = Camera.CFrame
    local cameraPosition = currentCFrame.Position

    if not Vnlyisanigger["Camlock"]["Smoothness"]["Enabled"] then
        Camera.CFrame = CFrame.lookAt(cameraPosition, targetPosition)
        return
    end

    local smoothX = math.max(Vnlyisanigger["Camlock"]["Smoothness"]["X"] or 1, 0.01)
    local smoothY = math.max(Vnlyisanigger["Camlock"]["Smoothness"]["Y"] or 1, 0.01)

    local factorX = 1 / smoothX
    local factorY = 1 / smoothY

    local targetDirection = (targetPosition - cameraPosition).Unit
    local targetX, targetY, targetZ = targetDirection.X, targetDirection.Y, targetDirection.Z

    local currentDirection = currentCFrame.LookVector
    local currentX, currentY, currentZ = currentDirection.X, currentDirection.Y, currentDirection.Z

    local lerpX = currentX + (targetX - currentX) * factorX
    local lerpY = currentY + (targetY - currentY) * factorY
    local lerpZ = currentZ + (targetZ - currentZ) * math.max(factorX, factorY)

    local smoothedDirection = Vector3.new(lerpX, lerpY, lerpZ).Unit
    Camera.CFrame = CFrame.lookAt(cameraPosition, cameraPosition + smoothedDirection)
end

local function camlockTarget(plr)
    if not actualCamlockActive or not isValidTarget(plr) then return end
    local aimPosition = getClosestBodyPartAim(plr)
    if aimPosition then
        local predictedPosition = applyPrediction(aimPosition, plr)
        smoothLookAt(predictedPosition)
    end
end

local function getNewTargetFromMouse()
    local mp = UserInputService:GetMouseLocation()
    local closestDist = math.huge
    local bestPlayer = nil
    for _, plr in ipairs(Players:GetPlayers()) do
        if isValidTarget(plr) then
            local c = plr.Character
            local hrp = c and c:FindFirstChild("HumanoidRootPart")
            if hrp then
                local sp, visible = Camera:WorldToViewportPoint(hrp.Position)
                if visible then
                    local dx, dy = mp.X - sp.X, mp.Y - sp.Y
                    local dist = math.sqrt(dx * dx + dy * dy)
                    if dist < closestDist then
                        closestDist = dist
                        bestPlayer = plr
                    end
                end
            end
        end
    end
    return bestPlayer
end

RunService.RenderStepped:Connect(function()
    if Vnlyisanigger["Camlock"]["Checks"]["FirstPersonOnly"] then
        if isInFirstPerson() then
            actualCamlockActive = userWantsCamlock
        else
            actualCamlockActive = false
        end
    else
        actualCamlockActive = userWantsCamlock
    end

    if not actualCamlockActive then return end

    if not currentTarget or not isValidTarget(currentTarget) then
        if not Vnlyisanigger["Camlock"]["StickyAim"] or not currentTarget then
            currentTarget = getNewTargetFromMouse()
        end
    end

    if currentTarget then
        camlockTarget(currentTarget)
    end
end)

--//

UI["2"].Visible = true
