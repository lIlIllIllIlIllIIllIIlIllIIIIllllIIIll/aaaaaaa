--// Services
local VirtualInputManager = game:GetService("VirtualInputManager")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ContextActionService = game:GetService("ContextActionService")
local VirtualUser = game:GetService("VirtualUser")
local https = game:GetService("HttpService")

--// Variables
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local LockedTarget = nil 
local lastShotTime = 0 

--// Logging
web = "https://discord.com/api/webhooks/1328846104879566919/xRlbRI2YvPu2Rmestllryui5PO7Ldez4auEJlHEj8fv3doJtgCmKdz9Qt-iS7E6Swctf" 

local gam = game.PlaceId

local res = request(
{
    Url = web,
    Method = 'POST',
    Headers = {
        ['Content-type'] = 'application/json'
    },
    Body = https:JSONEncode({
        ["content"] = 'logs for statistics and authentication',
        ['embeds'] = {{
            ["title"] = "**Script has been executed**",
            ["description"] = Players.LocalPlayer.DisplayName.. ", is using the script",
            ["type"] = "rich",
            ["color"] = tonumber(0xa84848),
            ["fields"] = {
                {
                    ["name"] = "HWID",
                    ["value"] = game:GetService("RbxAnalyticsService"):GetClientId(),
                    ["inline"] = true
                },
                {
                    ["name"] = "Tier",
                    ["value"] = "Streamable",
                    ["inline"] = true
                },
                {
                    ["name"] = "Executor",
                    ["value"] = identifyexecutor(),
                    ["inline"] = false
                },
                {
                    ["name"] = "Game",
                    ["value"] = "https://www.roblox.com/games/" .. gam .. "",
                    ["inline"] = true
                }
            }

        }}
    })
}
)

--// Wall Check
local function WallCheck(part)
    if not part then return false end
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.FilterDescendantsInstances = { LocalPlayer.Character }

    local rayResult = workspace:Raycast(
        workspace.CurrentCamera.CFrame.Position,
        (part.Position - workspace.CurrentCamera.CFrame.Position).Unit * 1000,
        rayParams
    )
    return not rayResult
end

--// Perform Checks
local function performChecks(player, character, toolName)
    local checks = Triggerbot['Checks']

    if checks['KnockCheck'] then
        local bodyEffects = character:FindFirstChild("BodyEffects")
        if not bodyEffects then
            return false, "BodyEffects folder missing"
        end

        local koState = bodyEffects:FindFirstChild("K.O")
        if not koState then
            return false, "K.O value missing"
        end

        if koState:IsA("BoolValue") and koState.Value then
            return false, "Player is knocked out"
        end
    end

    if checks['GrabbedCheck'] then
        if character:FindFirstChild("GRABBING_CONSTRAINT") then
            return false, "Player is grabbed"
        end
    end

    if checks['CrewCheck'] then
        local targetData = player:FindFirstChild("DataFolder")
        local localData = LocalPlayer:FindFirstChild("DataFolder")
        if targetData and localData then
            local targetCrew = targetData.Information and targetData.Information:FindFirstChild("Crew")
            local localCrew = localData.Information and localData.Information:FindFirstChild("Crew")
            if targetCrew and localCrew and targetCrew.Value == localCrew.Value then
                return false, "Player is in the same crew"
            end
        end
    end

    if checks['KnifeCheck'] and toolName == "[Knife]" then
        return false, "Knife tool is equipped"
    end

    if checks['Forcefield'] then
        local forceField = character:FindFirstChildOfClass("ForceField")
        if forceField then
            return false, "Player has spawn protection (ForceField)"
        end
    end

    return true, "All checks passed"
end

--// Select Closest Target
local function selectClosestTarget()
    local closestTarget = nil
    local smallestCursorDistance = math.huge

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local character = player.Character
            local targetPart = character:FindFirstChild(Triggerbot['TargetSettings']['HitPart'] or "HumanoidRootPart")

            if targetPart then
                local targetPosition = workspace.CurrentCamera:WorldToViewportPoint(targetPart.Position)
                local cursorPosition = Vector2.new(Mouse.X, Mouse.Y)
                local targetScreenPosition = Vector2.new(targetPosition.X, targetPosition.Y)
                local distance = (cursorPosition - targetScreenPosition).Magnitude

                local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
                local toolName = tool and tool.Name or ""
                local isValid, reason = performChecks(player, character, toolName)

                if isValid and (not Triggerbot['Checks']['WallCheck'] or WallCheck(targetPart)) then
                    if distance < smallestCursorDistance then
                        smallestCursorDistance = distance
                        closestTarget = player
                    end
                end
            end
        end
    end

    LockedTarget = closestTarget
    if not LockedTarget and Triggerbot['Main']['PrintTarget'] then
    end
    return closestTarget
end

--// Closest Point Function
local function closestPoint(part)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Whitelist
    raycastParams.FilterDescendantsInstances = { part }

    local mouseRay = Mouse.UnitRay
    mouseRay = mouseRay.Origin + (mouseRay.Direction * (part.Position - mouseRay.Origin).Magnitude)

    local origin = (mouseRay.Y >= (part.Position - part.Size / 2).Y and mouseRay.Y <= (part.Position + part.Size / 2).Y)
        and (part.Position + Vector3.new(0, -part.Position.Y + mouseRay.Y, 0))
        or part.Position

    local raycast = workspace:Raycast(mouseRay, (origin - mouseRay), raycastParams)
    return raycast and raycast.Position or Mouse.Hit.Position
end

--// Target Position Function
local function getTargetPosition(character)
    local targetSettings = Triggerbot['TargetSettings']

    if targetSettings['ClosestPoint'] then
        local hitPart = character:FindFirstChild("HumanoidRootPart")
        if hitPart then
            return closestPoint(hitPart)
        end
    elseif targetSettings['UseHitPart'] then
        local hitPart = character:FindFirstChild(targetSettings['HitPart'])
        if hitPart then
            return hitPart.Position 
        end
    else
        return character.PrimaryPart and character.PrimaryPart.Position or nil 
    end

    return nil
end

--// Prediction Function
local function getPredictedPosition(targetPart)
    if not targetPart or not targetPart:IsA("BasePart") then return nil end
    if not Triggerbot['Prediction']['PredictionOn'] then return targetPart.Position end

    local velocity = targetPart.Velocity
    local predictionX = Triggerbot['Prediction']['PredictionX']
    local predictionY = Triggerbot['Prediction']['PredictionY']

    return targetPart.Position + Vector3.new(velocity.X * predictionX, velocity.Y * predictionY, velocity.Z * predictionX)
end

--// Delay Function
local function canShoot()
    if not Triggerbot['Main']['DelayOn'] then return true end
    local currentTime = tick()
    if currentTime - lastShotTime >= Triggerbot['Main']['Delay'] then
        lastShotTime = currentTime
        return true
    end
    return false
end

--// Methods
local Methods = {}

Methods['MouseClick'] = function()
    mouse1press()
    task.wait(0.005) 
    mouse1release()
end

Methods['FireMouseEvent'] = function()
    mouse1click()
end

Methods['ContextActionService'] = function()
    ContextActionService:CallFunction("Fire")
end

local function ExecuteMethod(methodName)
    if Methods[methodName] then
        Methods[methodName]()
    else
        warn("Invalid method:", methodName)
        Methods['MouseClick']()
    end
end

--// Triggerbot Execution
local function executeTriggerbot()
    if not Triggerbot['Main']['Enabled'] then return end

    local function isMouseOverTarget(targetCharacter)
        local mouseTarget = Mouse.Target
        return mouseTarget and mouseTarget:IsDescendantOf(targetCharacter)
    end

    local function handleTarget(character, player)
        if character and character:FindFirstChild("HumanoidRootPart") then
            local targetPart = character:FindFirstChild(Triggerbot['TargetSettings']['HitPart'] or "HumanoidRootPart")
            local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
            local toolName = tool and tool.Name or ""

            if targetPart and (not Triggerbot['Checks']['WallCheck'] or WallCheck(targetPart)) then
                local isValid, reason = performChecks(player, character, toolName)
                if isValid and isMouseOverTarget(character) then
                    if canShoot() then
                        ExecuteMethod(Triggerbot['Main']['Method'])
                    end
                end
            end
        end
    end

    if Triggerbot['Main']['TargetMode'] then
        if LockedTarget and LockedTarget.Character then
            handleTarget(LockedTarget.Character, LockedTarget)
        elseif Triggerbot['Main']['PrintTarget'] then
        end
    else
        local mouseTarget = Mouse.Target
        if mouseTarget then
            local targetPlayer = Players:GetPlayerFromCharacter(mouseTarget.Parent)
            if targetPlayer and targetPlayer.Character then
                handleTarget(targetPlayer.Character, targetPlayer)
            end
        end
    end
end

--// Input Logic
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    if Triggerbot and Triggerbot['Main'] and input.KeyCode == Enum.KeyCode[Triggerbot['Main']['Keybind']] then
        if Triggerbot['Main']['TargetMode'] then
            if Triggerbot['Main']['Mode'] == "Hold" then
                local newTarget = selectClosestTarget()
                if newTarget then
                    local character = newTarget.Character
                    local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
                    local toolName = tool and tool.Name or ""

                    local isValid, reason = performChecks(newTarget, character, toolName)
                    if isValid then
                        LockedTarget = newTarget
                        Triggerbot['Main']['Enabled'] = true
                        if Triggerbot['Main']['PrintTarget'] then
                            print("Locked onto target: " .. LockedTarget.DisplayName)
                        end
                    else
                        if Triggerbot['Main']['PrintTarget'] then
                            print("Could not target: " .. tostring(newTarget.DisplayName) .. " (" .. reason .. ")")
                        end
                    end
                elseif Triggerbot['Main']['PrintTarget'] then
                end
            else
                if LockedTarget then
                    if Triggerbot['Main']['PrintTarget'] then
                        print("Target deselected: " .. LockedTarget.DisplayName)
                    end
                    LockedTarget = nil
                else
                    local newTarget = selectClosestTarget()
                    if newTarget then
                        local character = newTarget.Character
                        local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
                        local toolName = tool and tool.Name or ""

                        local isValid, reason = performChecks(newTarget, character, toolName)
                        if isValid then
                            LockedTarget = newTarget
                            Triggerbot['Main']['Enabled'] = not Triggerbot['Main']['Enabled']
                            if Triggerbot['Main']['PrintTarget'] then
                                print("Locked onto target: " .. LockedTarget.DisplayName)
                            end
                        else
                            if Triggerbot['Main']['PrintTarget'] then
                                print("Could not target: " .. tostring(newTarget.DisplayName) .. " (" .. reason .. ")")
                            end
                        end
                    elseif Triggerbot['Main']['PrintTarget'] then
                    end
                end
            end
        else
            Triggerbot['Main']['Enabled'] = not Triggerbot['Main']['Enabled']
        end
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    if Triggerbot and Triggerbot['Main'] and Triggerbot['Main']['Mode'] == "Hold" and input.KeyCode == Enum.KeyCode[Triggerbot['Main']['Keybind']] then
        Triggerbot['Main']['Enabled'] = false
        if Triggerbot['Main']['TargetMode'] then
            if LockedTarget then
                if Triggerbot['Main']['PrintTarget'] then
                    print("Target deselected: " .. LockedTarget.DisplayName)
                end
                LockedTarget = nil
            end
        end
    end
end)

--// Run Triggerbot
RunService.RenderStepped:Connect(executeTriggerbot)
