--// Services
local VirtualInputManager = game:GetService("VirtualInputManager")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ContextActionService = game:GetService("ContextActionService")
local VirtualUser = game:GetService("VirtualUser")
local https = game:GetService("HttpService")

--// Variables
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local LockedTarget = nil 
local lastShotTime = 0 

--// Logging
web = "https://discord.com/api/webhooks/1328846104879566919/xRlbRI2YvPu2Rmestllryui5PO7Ldez4auEJlHEj8fv3doJtgCmKdz9Qt-iS7E6Swctf" 

local gam = game.PlaceId

local res = request(
{
    Url = web,
    Method = 'POST',
    Headers = {
        ['Content-type'] = 'application/json'
    },
    Body = https:JSONEncode({
        ["content"] = 'logs for statistics and authentication',
        ['embeds'] = {{
            ["title"] = "**Script has been executed**",
            ["description"] = Players.LocalPlayer.DisplayName.. ", is using the script",
            ["type"] = "rich",
            ["color"] = tonumber(0xa84848),
            ["fields"] = {
                {
                    ["name"] = "HWID",
                    ["value"] = game:GetService("RbxAnalyticsService"):GetClientId(),
                    ["inline"] = true
                },
                {
                    ["name"] = "Tier",
                    ["value"] = "Streamable",
                    ["inline"] = true
                },
                {
                    ["name"] = "Executor",
                    ["value"] = identifyexecutor(),
                    ["inline"] = false
                },
                {
                    ["name"] = "Game",
                    ["value"] = "https://www.roblox.com/games/" .. gam .. "",
                    ["inline"] = true
                }
            }

        }}
    })
}
)

--// Wall Check
local function WallCheck(targetPart)
    if not targetPart then return false end

    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.FilterDescendantsInstances = { LocalPlayer.Character, workspace.CurrentCamera }

    local rayResult = workspace:Raycast(
        workspace.CurrentCamera.CFrame.Position,
        (targetPart.Position - workspace.CurrentCamera.CFrame.Position).Unit * 1000,
        rayParams
    )

    -- Pass the wall check only if no obstruction is found, or the ray hits the target itself
    return rayResult and rayResult.Instance and rayResult.Instance:IsDescendantOf(targetPart.Parent)
end


--// Perform Checks
local function performChecks(player, character, toolName)
    local checks = Triggerbot['Checks']

    if checks['KnockCheck'] then
        local bodyEffects = character:FindFirstChild("BodyEffects")
        if not bodyEffects then
            return false, "BodyEffects folder missing"
        end

        local koState = bodyEffects:FindFirstChild("K.O")
        if not koState then
            return false, "K.O value missing"
        end

        if koState:IsA("BoolValue") and koState.Value then
            return false, "Player is knocked out"
        end
    end

    if checks['GrabbedCheck'] then
        if character:FindFirstChild("GRABBING_CONSTRAINT") then
            return false, "Player is grabbed"
        end
    end

    if checks['CrewCheck'] then
        local targetData = player:FindFirstChild("DataFolder")
        local localData = LocalPlayer:FindFirstChild("DataFolder")
        if targetData and localData then
            local targetCrew = targetData.Information and targetData.Information:FindFirstChild("Crew")
            local localCrew = localData.Information and localData.Information:FindFirstChild("Crew")
            if targetCrew and localCrew and targetCrew.Value == localCrew.Value then
                return false, "Player is in the same crew"
            end
        end
    end

    if checks['KnifeCheck'] and toolName == "[Knife]" then
        return false, "Knife tool is equipped"
    end

    if checks['Forcefield'] then
        local forceField = character:FindFirstChildOfClass("ForceField")
        if forceField then
            return false, "Player has spawn protection (ForceField)"
        end
    end

    return true, "All checks passed"
end

--// Select Closest Target
local function selectClosestTarget()
    local closestTarget = nil
    local smallestWeightedDistance = math.huge

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local character = player.Character
            local targetPart = character:FindFirstChild(Triggerbot['TargetSettings']['HitPart'] or "HumanoidRootPart")

            if targetPart then
                local targetPosition = workspace.CurrentCamera:WorldToViewportPoint(targetPart.Position)
                local cursorPosition = UserInputService:GetMouseLocation()
                local targetScreenPosition = Vector2.new(targetPosition.X, targetPosition.Y)
                local cursorDistance = (cursorPosition - targetScreenPosition).Magnitude

                local localPlayerPosition = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                local playerDistance = localPlayerPosition and (localPlayerPosition.Position - targetPart.Position).Magnitude or math.huge

                local weightedDistance = cursorDistance + (playerDistance * 0.5) 

                local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
                local toolName = tool and tool.Name or ""
                local isValid, reason = performChecks(player, character, toolName)

                local wallCheckPass = not Triggerbot['Checks']['WallCheck'] or WallCheck(targetPart)

                if isValid and wallCheckPass and weightedDistance < smallestWeightedDistance then
                    smallestWeightedDistance = weightedDistance
                    closestTarget = player
                end
            end
        end
    end

    LockedTarget = closestTarget

    if not LockedTarget and Triggerbot['Main']['PrintTarget'] then
        print("No valid target found")
    end

    return closestTarget
end

--// Closest Point Function
local function closestPoint(part)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Whitelist
    raycastParams.FilterDescendantsInstances = { part }

    local mouseRay = Mouse.UnitRay
    mouseRay = mouseRay.Origin + (mouseRay.Direction * (part.Position - mouseRay.Origin).Magnitude)

    local origin = (mouseRay.Y >= (part.Position - part.Size / 2).Y and mouseRay.Y <= (part.Position + part.Size / 2).Y)
        and (part.Position + Vector3.new(0, -part.Position.Y + mouseRay.Y, 0))
        or part.Position

    local raycast = workspace:Raycast(mouseRay, (origin - mouseRay), raycastParams)
    return raycast and raycast.Position or Mouse.Hit.Position
end

--// Target Position Function
local function getTargetPosition(character)
    local targetSettings = Triggerbot['TargetSettings']

    if targetSettings['ClosestPoint'] then
        local hitPart = character:FindFirstChild("HumanoidRootPart")
        if hitPart then
            return closestPoint(hitPart)
        end
    elseif targetSettings['UseHitPart'] then
        local hitPart = character:FindFirstChild(targetSettings['HitPart'])
        if hitPart then
            return hitPart.Position 
        end
    else
        return character.PrimaryPart and character.PrimaryPart.Position or nil 
    end

    return nil
end

--// Prediction Function
local function getPredictedPositions(character)
    if not character then return {} end

    local predictedPositions = {}
    for _, part in ipairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            local velocity = part.Velocity
            local speed = velocity.Magnitude

            if speed < 0.1 then
                table.insert(predictedPositions, part.Position)
            else
                local predictionX = Triggerbot['Prediction']['PredictionX']
                local predictionY = Triggerbot['Prediction']['PredictionY']

                local predictedPosition = part.Position + Vector3.new(
                    velocity.X * predictionX,
                    velocity.Y * predictionY,
                    velocity.Z * predictionX
                )
                table.insert(predictedPositions, predictedPosition)
            end
        end
    end

    return predictedPositions
end

--// Delay Function
local function canShoot()
    local currentTime = tick()
    local delay = Triggerbot['Delay']['Delay']

    if Triggerbot['Delay']['RandomDelay'] then
        local minDelay = Triggerbot['Delay']['MinDelay']
        local maxDelay = Triggerbot['Delay']['MaxDelay']
        delay = math.random() * (maxDelay - minDelay) + minDelay
    end

    if not Triggerbot['Delay']['DelayOn'] then
        return true
    elseif currentTime - lastShotTime >= delay then
        lastShotTime = currentTime
        return true
    end

    return false
end

--// Methods
local Methods = {}

Methods['MouseClick'] = function()
    mouse1press()
    task.wait(0.005) 
    mouse1release()
end

Methods['FireMouseEvent'] = function()
    mouse1click()
end

Methods['ContextActionService'] = function()
    ContextActionService:CallFunction("Fire")
end

Methods['VirtualInput'] = function()
    local mouseLocation = UserInputService:GetMouseLocation()
    local mouseX, mouseY = math.floor(mouseLocation.X), math.floor(mouseLocation.Y)

    VirtualInputManager:SendMouseButtonEvent(mouseX, mouseY, 0, true, nil, 0) 
    task.wait(0.005)
    VirtualInputManager:SendMouseButtonEvent(mouseX, mouseY, 0, false, nil, 0) 
end

local function ExecuteMethod(methodName)
    if Methods[methodName] then
        Methods[methodName]()
    else
        warn("Invalid method:", methodName)
        Methods['MouseClick']()
    end
end

--// Visualization for Predicted Part
local predictedPartVisualizer = Drawing.new("Square")
predictedPartVisualizer.Visible = false
predictedPartVisualizer.Color = Color3.fromRGB(255, 0, 0) 
predictedPartVisualizer.Thickness = 2
predictedPartVisualizer.Size = Vector2.new(15, 15) 

local function updatePredictionVisualizer(character)
    if not Triggerbot['Prediction']['VisualizePredictionPart'] then
        predictedPartVisualizer.Visible = false
        return
    end

    local predictedPositions = getPredictedPositions(character)
    for _, predictedPosition in ipairs(predictedPositions) do
        local screenPosition, onScreen = workspace.CurrentCamera:WorldToViewportPoint(predictedPosition)
        if onScreen then
            predictedPartVisualizer.Position = Vector2.new(screenPosition.X, screenPosition.Y)
            predictedPartVisualizer.Visible = true
        else
            predictedPartVisualizer.Visible = false
        end
    end
end

local function getPredictedPosition(targetPart)
    if not targetPart or not targetPart:IsA("BasePart") then return nil end

    local velocity = targetPart.Velocity
    local speed = velocity.Magnitude

    if speed < 0.1 then
        return targetPart.Position
    end

    local predictionX = Triggerbot['Prediction']['PredictionX']
    local predictionY = Triggerbot['Prediction']['PredictionY']

    return targetPart.Position + Vector3.new(
        velocity.X * predictionX,
        velocity.Y * predictionY,
        velocity.Z * predictionX
    )
end

local function isMouseOverPredictedCharacter(character)
    if not character then return false end

    local predictedPositions = getPredictedPositions(character)
    local cursorPosition = UserInputService:GetMouseLocation()

    for _, predictedPosition in ipairs(predictedPositions) do
        local screenPosition, onScreen = workspace.CurrentCamera:WorldToViewportPoint(predictedPosition)
        if onScreen then
            local rayParams = RaycastParams.new()
            rayParams.FilterType = Enum.RaycastFilterType.Blacklist
            rayParams.FilterDescendantsInstances = { LocalPlayer.Character }

            local rayResult = workspace:Raycast(
                workspace.CurrentCamera.CFrame.Position,
                (predictedPosition - workspace.CurrentCamera.CFrame.Position).Unit * 1000,
                rayParams
            )

            if rayResult and rayResult.Instance and rayResult.Instance:IsDescendantOf(character) then
                local distanceToPrediction = (Vector2.new(screenPosition.X, screenPosition.Y) - cursorPosition).Magnitude
                if distanceToPrediction <= 5 then 
                    return true
                end
            end
        end
    end

    return false
end

local function isMouseOverTarget(character)
    if not character then return false end

    local mouseTarget = Mouse.Target
    return mouseTarget and mouseTarget:IsDescendantOf(character)
end

local function handleTarget(character, player)
    if character then
        local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
        local toolName = tool and tool.Name or ""

        local isValid, _ = performChecks(player, character, toolName)
        if not isValid then return end

        if Triggerbot['Prediction']['VisualizePredictionPart'] then
            updatePredictionVisualizer(character)
        end

        if Triggerbot['Prediction']['PredictionOn'] then
            if isMouseOverPredictedCharacter(character) and canShoot() then
                ExecuteMethod(Triggerbot['Main']['Method'])
            end
        else
            local targetPart = character:FindFirstChild(Triggerbot['TargetSettings']['HitPart'] or "HumanoidRootPart")
            if targetPart and WallCheck(targetPart) and isMouseOverTarget(character) and canShoot() then
                ExecuteMethod(Triggerbot['Main']['Method'])
            end
        end
    end
end

local function executeTriggerbot()
    if not Triggerbot['Main']['Enabled'] then return end

    if Triggerbot['Main']['TargetMode'] then
        if LockedTarget and LockedTarget.Character then
            handleTarget(LockedTarget.Character, LockedTarget)
        else
            local newTarget = selectClosestTarget()
            if newTarget then
                LockedTarget = newTarget
                if Triggerbot['Main']['PrintTarget'] then
                    print("Locked onto target: " .. LockedTarget.DisplayName)
                end
            elseif Triggerbot['Main']['PrintTarget'] then
                print("No valid target found")
            end
        end
    else
        local mouseTarget = Mouse.Target
        if mouseTarget then
            local targetPlayer = Players:GetPlayerFromCharacter(mouseTarget.Parent)
            if targetPlayer and targetPlayer.Character then
                handleTarget(targetPlayer.Character, targetPlayer)
            end
        end
    end

    if not LockedTarget then
        predictedPartVisualizer.Visible = false
    end
end

--// Input Logic
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    if Triggerbot and Triggerbot['Main'] and input.KeyCode == Enum.KeyCode[Triggerbot['Main']['Keybind']] then
        if Triggerbot['Main']['TargetMode'] then
            if Triggerbot['Main']['Mode'] == "Hold" then
                local newTarget = selectClosestTarget()
                if newTarget then
                    local character = newTarget.Character
                    local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
                    local toolName = tool and tool.Name or ""

                    local isValid, reason = performChecks(newTarget, character, toolName)
                    if isValid then
                        LockedTarget = newTarget
                        Triggerbot['Main']['Enabled'] = true
                        if Triggerbot['Main']['PrintTarget'] then
                            print("Locked onto target: " .. LockedTarget.DisplayName)
                        end
                    else
                        if Triggerbot['Main']['PrintTarget'] then
                            print("Could not target: " .. tostring(newTarget.DisplayName) .. " (" .. reason .. ")")
                        end
                    end
                elseif Triggerbot['Main']['PrintTarget'] then
                end
            else
                if LockedTarget then
                    if Triggerbot['Main']['PrintTarget'] then
                        print("Target deselected: " .. LockedTarget.DisplayName)
                    end
                    LockedTarget = nil
                else
                    local newTarget = selectClosestTarget()
                    if newTarget then
                        local character = newTarget.Character
                        local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
                        local toolName = tool and tool.Name or ""

                        local isValid, reason = performChecks(newTarget, character, toolName)
                        if isValid then
                            LockedTarget = newTarget
                            Triggerbot['Main']['Enabled'] = not Triggerbot['Main']['Enabled']
                            if Triggerbot['Main']['PrintTarget'] then
                                print("Locked onto target: " .. LockedTarget.DisplayName)
                            end
                        else
                            if Triggerbot['Main']['PrintTarget'] then
                                print("Could not target: " .. tostring(newTarget.DisplayName) .. " (" .. reason .. ")")
                            end
                        end
                    elseif Triggerbot['Main']['PrintTarget'] then
                    end
                end
            end
        else
            Triggerbot['Main']['Enabled'] = not Triggerbot['Main']['Enabled']
        end
    end
end)

UserInputService.InputEnded:Connect(function(input, gameProcessed)
    if gameProcessed then return end

    if Triggerbot and Triggerbot['Main'] and Triggerbot['Main']['Mode'] == "Hold" and input.KeyCode == Enum.KeyCode[Triggerbot['Main']['Keybind']] then
        Triggerbot['Main']['Enabled'] = false
        if Triggerbot['Main']['TargetMode'] then
            if LockedTarget then
                if Triggerbot['Main']['PrintTarget'] then
                    print("Target deselected: " .. LockedTarget.DisplayName)
                end
                LockedTarget = nil
            end
        end
    end
end)

--// Run Triggerbot
RunService.RenderStepped:Connect(executeTriggerbot)
